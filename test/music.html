<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body onload="init()">
    <button onclick="play()">play</button>
    <button onclick="stop()">stop</button>
    <button onclick="resume()">resume</button>
    <button onclick="suspend()">suspend</button>
    <button onclick="createSound()">createSound</button>
    <button onclick="lowpassFilter()">lowpassFilter</button>
    <button onclick="highpassFilter()">highpassFilter</button>
    <button onclick="enhanceVocal()">enhanceVocal</button>
    <button onclick="removeVocal()">removeVocal</button>
    <button onclick="splitterMerger()">splitterMerger</button>
    <button onclick="delay()">delay</button>
    <button onclick="cancelEffect()">cancelEffect</button>


    <div>
        <input type="range" name="stereo" value="50" id="stereo" onchange="stereo()"><label for="stereo">stereo</label>
    </div>
    <div>
        <input type="range" name="volume" value="50" id="handleVol" oninput="handleVol()"><label
            for="handleVol">volume</label>
    </div>
    <div>
        <input type="range" name="seek" value="0" id="handleSeek" onchange="handleSeek()"><label
            for="handleSeek">seek</label>
    </div>




</body>
<script src="axios.js"></script>

<script>


    const url = "http://m7.music.126.net/20200107111345/998ef3076eb6493b9be81f7e43437de4/ymusic/e796/34ad/499a/32c27f4dc29f21334d41e5929549906f.mp3"

    var context, source, gain, analyser, filter, audio;
    function handleVol() {
        const value = document.querySelector("input[name='volume']").value;
        gain.gain.value = (value / 100);
    }
    async function handleSeek() {
        const value = document.querySelector("input[name='seek']").value;
        const len = audio.duration;
        const playtime = (value * len / 100);
        audio.currentTime = playtime;
        // stop();
        // await init();
        // source.start(0, playtime)
    }
    // async function play() {
    //     gain.gain.value = 0;
    //     const value = document.getElementById('vlo').value;
    //     source.start(0);//开始播放
    //     gain.gain.linearRampToValueAtTime(value / 100, 10)
    // }
    // function stop() {
    //     gain.gain.linearRampToValueAtTime(0, 10)

    //     // source.stop()
    // }
    // async function resume() {
    //     // const currentTime = context.currentTime;
    //     // filter.disconnect(0)
    //     // await init();
    //     // source.start(0, currentTime)
    //     // const value = document.getElementById('vlo').value;
    //     context.resume()
    //     // gain.gain.value = 0;
    //     // gain.gain.linearRampToValueAtTime(value / 100, context.currentTime + 10)
    // }
    // function suspend() {
    //     // gain.gain.linearRampToValueAtTime(0, context.currentTime + 10)
    //     // setTimeout(() => {
    //     context.suspend()
    //     // }, 1000)
    // }
    async function init() {
        audio = new Audio();
        audio.crossOrigin = "anonymous";
        audio.src = url;
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        context = new AudioContext();
        source = context.createMediaElementSource(audio);
        gain = context.createGain();
        gain.gain.value = 0.5;
        analyser = context.createAnalyser();
        analyser.fftSize = 2048;
        source.connect(gain)
        gain.connect(context.destination);
        audio.oncanplay = () => {
            //已经能够播放
            /**
             * TODO
             */
            console.log(audio.currentTime, audio.duration, audio);

        };

        // resume()
    }
    //淡入声音
    function resume() {
        gain.gain.value = 0;
        audio.play();
        let currentTime = context.currentTime;
        gain.gain.linearRampToValueAtTime(1, currentTime + 0.8);
    }
    //淡出声音
    function suspend() {
        let currentTime = context.currentTime;
        gain.gain.linearRampToValueAtTime(0, currentTime + 0.8);
        setTimeout(() => {
            audio.pause();
        }, 0.8 * 800); // 延时
    }
    function stop() {
        let currentTime = context.currentTime;
        gain.gain.linearRampToValueAtTime(0, currentTime + 0.8);
        setTimeout(() => {
            audio.stop();
        }, 0.8 * 800); // 延时

        // source.stop()
    }
    function createSound() {
		/*
		 * 标准 la 音为440hz， 高8音的频率为原音频的2倍
		 * 音阶换算公式: n个半音 = 12 * log2(f1 / f2) (其中, f1 < f2时n < 0, 反之n > 0);
		 * ->已知f2, 求f1, 其中 f1 小 f2 n个半音
		 * ->则 f1 = f2 * Math.pow(2, -n / 12);
		 */
        let i = Math.ceil(Math.random() * 10),
            hz = 440;

        // create Oscillator node
        let oscillator = context.createOscillator();

        oscillator.frequency.value = hz * i; // value in hertz
        oscillator.connect(context.destination);
        oscillator.start();
        setTimeout(() => {
            oscillator.stop();
        }, 300);
    }
    function disconnect() {
        gain.disconnect(0);
        analyser.disconnect(0);
    }
    function stereo(r) {
        disconnect();
        let panner = context.createPanner();
        let gain1 = context.createGain();

        let index = 0,
            radius = r || 20;
        panner.setOrientation(0, 0, 0, 0, 1, 0);
        // 让声源绕着收听者以20的半径旋转
        this.effectTimer = setInterval(() => {
            panner.setPosition(Math.sin(index) * radius, 0, Math.cos(index) * radius);
            index += 1 / 100;
        }, 16);
        gain1.gain.value = 1;
        gain.connect(gain1);
        gain.connect(panner);
        panner.connect(this.analyser);
        analyser.connect(context.destination);
    }

    /*
	 * 低通滤波器
	 */
    function lowpassFilter(freq) {
        disconnect();
        let biquadFilter = context.createBiquadFilter();
        biquadFilter.type = 'lowpass'; // 低阶通过
        biquadFilter.Q.value = 2;
        biquadFilter.frequency.value = freq || 800; // 临界点的 Hz，默认800Hz
        gain.connect(biquadFilter);
        biquadFilter.connect(analyser);
        analyser.connect(context.destination);
    }


	/*
	 * 高通滤波器
	 */
    function highpassFilter(freq) {
        disconnect();
        let biquadFilter = context.createBiquadFilter();
        biquadFilter.type = 'highpass'; // 低阶通过
        biquadFilter.Q.value = 4;
        biquadFilter.frequency.value = freq || 800; // 临界点的 Hz，默认800Hz
        gain.connect(biquadFilter);
        biquadFilter.connect(analyser);
        analyser.connect(context.destination);
    }
    /*
	 * 人声增益 -- perfect -- 
	 */
    function enhanceVocal() {
        disconnect();
        let gain1 = context.createGain(),
            gain2 = context.createGain(),
            channelSplitter = context.createChannelSplitter(2),
            channelMerger = context.createChannelMerger(2);

        gain1.gain.value = 2;
        gain2.gain.value = 2;

        gain.connect(channelSplitter);

        channelSplitter.connect(gain1, 0);
        gain1.connect(channelMerger, 0, 1);
        channelSplitter.connect(channelMerger, 1, 1);

        channelSplitter.connect(gain2, 1);
        gain2.connect(channelMerger, 0, 0);
        channelSplitter.connect(channelMerger, 0, 0);

        channelMerger.connect(analyser);
        analyser.connect(context.destination);
    }

    function removeVocal() {
        disconnect();
        let gain1 = context.createGain(),
            gain2 = context.createGain(),
            gain3 = context.createGain(),
            channelSplitter = context.createChannelSplitter(2),
            channelMerger = context.createChannelMerger(2);

        // 反相音频组合
        gain1.gain.value = -1;
        gain2.gain.value = -1;

        gain.connect(this.analyser);
        analyser.connect(channelSplitter);

        // 交叉音轨，减去相同的音频部分（即人声）
        channelSplitter.connect(gain1, 0);
        gain1.connect(channelMerger, 0, 1);
        channelSplitter.connect(channelMerger, 1, 1);

        channelSplitter.connect(gain2, 1);
        gain2.connect(channelMerger, 0, 0);
        channelSplitter.connect(channelMerger, 0, 0);

        channelMerger.connect(gain3);
        gain3.connect(context.destination);
    }
    /*
	 * 延时，回声效果
	 */
    function delay() {
        disconnect();

        let delay = context.createDelay();
        let gain1 = context.createGain();

        delay.delayTime.value = 0.06; // 延时0.06s
        gain1.gain.value = 1.2;

        // 两条平行通路

        // 1.source -> destination
        gain.connect(context.destination);

        // 2.source -> delay -> gain -> destination
        gain.connect(delay);
        delay.connect(gain1);
        gain1.connect(analyser);
        analyser.connect(context.destination);
    }
    /*
         * 清除音效，还原原声 
         */
    function cancelEffect() {
        disconnect();
        gain.connect(analyser);
        analyser.connect(context.destination);
    }
    /*
	 *  左声道和右声道的分离并单独处理，最后合并，左耳低阶增强，右耳伴奏增强
	 */
    function splitterMerger() {
        this.disconnect();
        let lGain = context.createGain();
        let rGain = context.createGain();
        // 声道离合器
        let splitter = context.createChannelSplitter(2);
        let merger = context.createChannelMerger(2);
        lGain.gain.value = 1;
        rGain.gain.value = 1;

        let leftFilter = context.createBiquadFilter();
        leftFilter.type = 'lowshelf';
        // leftFilter.Q.value = 2;
        leftFilter.gain.value = 10;
        leftFilter.frequency.value = 392;

        let rightFilter = context.createBiquadFilter();
        rightFilter.type = 'highshelf';
        // rightFilter.Q.value = 2;
        rightFilter.gain.value = 10;
        rightFilter.frequency.value = 82; // 临界点的 Hz，

        gain.connect(splitter);
        splitter.connect(lGain, 0);
        splitter.connect(rGain, 1);
        lGain.connect(leftFilter);
        rGain.connect(rightFilter);
        leftFilter.connect(merger, 0, 0);
        rightFilter.connect(merger, 0, 1);
        merger.connect(analyser);
        analyser.connect(context.destination);
    }
    async function init3() {
        return new Promise(async (reslove, reject) => {


            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            context = new AudioContext();
            console.time()
            console.log(`初始化完成${context}`);
            console.log(`开始fetch加载资源....`);
            const { data } = await axios({ method: 'GET', url, responseType: 'arraybuffer' });
            console.log(`fetch加载资源完成`);
            console.log(`decodeAudioData...`);
            buffer = await context.decodeAudioData(data)
            // buffer = context.decodeAudioData(data).then(e => console.log(e));
            console.log(`decodeAudioData 完成`);
            //播放资源
            source = context.createBufferSource();
            source.buffer = buffer;
            //音量控制器
            gain = context.createGain()
            gain.gain.value = 0.5;
            //动态效果控制器
            analyser = context.createAnalyser();
            analyser.fftSize = 2048
            console.log(source);

            // // 创建分析节点
            // analyser = context.createAnalyser();
            // analyser.fftSize = '';
            //音效控制器
            filter = context.createBiquadFilter();
            filter.type = 'allpass';// 低通 滤波器 详情可以见 BiquadFilterNode的文档
            // filter.frequency.value = 440;// 设置截止位置为 440HZ
            // Low Pass
            // High Pass
            // Band Pass
            // Low Shelf
            // High Shelf
            // Peaking
            // Notch
            // Allpass
            // 创建音频图像
            source.connect(filter);
            filter.connect(analyser);
            analyser.connect(gain);
            gain.connect(context.destination);

            //  设置filter的参数

            // source.start(0);//开始播放
            console.log(`开始播放`);
            console.timeEnd();
            reslove();
            source.onended = function (e) {
                console.log('onended', source, e);

            }
            context.onstatechange = function (e) {
                console.log('onstatechange', source, e);

            }

        })
    }


</script>

</html>